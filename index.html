<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Mandelbrot Set</title>
	<style>
		body {
			margin: 0;
			display: flex;
			justify-content: center;
			align-items: center;
			min-height: 100vh;
			background-color: #f0f0f0;
		}

		canvas {
			border: 1px solid black;
		}
	</style>
</head>

<body>
	<canvas id="mandelbrotCanvas" width="800" height="800"></canvas>

	<script>
		const canvas = document.getElementById('mandelbrotCanvas');
		const ctx = canvas.getContext('2d');

		const width = canvas.width;
		const height = canvas.height;

		// Complex plane boundaries
		let xMin = -2.5;
		let xMax = 1.5;
		let yMin = -2.0;
		let yMax = 2.0;

		const maxIterations = 100;
		const escapeRadiusSquared = 4;

		// Variables to track panning state
		let isPanning = false;
		let startPanX = 0;
		let startPanY = 0;

		// NEW: Store the canvas image data for quick redraws
		let lastImageData = null;

		function drawMandelbrot() {
			console.log("Starting high-quality draw...");
			ctx.fillStyle = "blue";
			ctx.fillRect(0, 0, width, height);

			setTimeout(() => {
				const imageData = ctx.createImageData(width, height);
				const pixels = imageData.data;

				for (let px = 0; px < width; px++) {
					for (let py = 0; py < height; py++) {
						const c_real = xMin + (px / width) * (xMax - xMin);
						const c_imag = yMin + (py / height) * (yMax - yMin);

						let zr = 0.0;
						let zi = 0.0;
						let iterations = 0;

						while (zr * zr + zi * zi < escapeRadiusSquared && iterations < maxIterations) {
							const zr_new = zr * zr - zi * zi + c_real;
							const zi_new = 2 * zr * zi + c_imag;
							zr = zr_new;
							zi = zi_new;
							iterations++;
						}

						const pixelIndex = (py * width + px) * 4;

						if (iterations === maxIterations) {
							pixels[pixelIndex] = 0;
							pixels[pixelIndex + 1] = 0;
							pixels[pixelIndex + 2] = 0;
							pixels[pixelIndex + 3] = 255;
						} else {
							const colorValue = Math.floor((iterations / maxIterations) * 255);
							pixels[pixelIndex] = colorValue;
							pixels[pixelIndex + 1] = colorValue * 2;
							pixels[pixelIndex + 2] = 255 - colorValue;
							pixels[pixelIndex + 3] = 255;
						}
					}
				}
				ctx.putImageData(imageData, 0, 0);
				// NEW: Save the result for fast panning
				lastImageData = ctx.getImageData(0, 0, width, height);
				console.log("Draw complete.");
			}, 0);
		}

		// Event listener for when the mouse button is pressed
		canvas.addEventListener('mousedown', (event) => {
			isPanning = true;
			startPanX = event.offsetX;
			startPanY = event.offsetY;
		});

		// Event listener for when the mouse moves
		canvas.addEventListener('mousemove', (event) => {
			if (!isPanning || !lastImageData) {
				return;
			}

			// NEW: This is the real-time feedback logic
			const deltaX = event.offsetX - startPanX;
			const deltaY = event.offsetY - startPanY;

			// Clear the canvas
			ctx.fillStyle = "blue";
			ctx.fillRect(0, 0, width, height);
			// Draw the last saved image, shifted by the mouse delta
			ctx.putImageData(lastImageData, deltaX, deltaY);
		});

		// Event listener for when the mouse button is released
		canvas.addEventListener('mouseup', (event) => {
			if (!isPanning) {
				return;
			}
			isPanning = false;

			const endPanX = event.offsetX;
			const endPanY = event.offsetY;
			const deltaX = endPanX - startPanX;
			const deltaY = endPanY - startPanY;

			if (deltaX === 0 && deltaY === 0) return; // Don't redraw if there was no pan

			const xRange = xMax - xMin;
			const yRange = yMax - yMin;

			const dx = (deltaX / width) * xRange;
			const dy = (deltaY / height) * yRange;

			xMin -= dx;
			xMax -= dx;
			yMin -= dy;
			yMax -= dy;

			// Redraw the mandelbrot set with the new coordinates
			drawMandelbrot();
		});

		drawMandelbrot();
	</script>
</body>

</html>