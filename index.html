<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Mandelbrot Set</title>
	<style>
		body {
			margin: 0;
			display: flex;
			justify-content: center;
			align-items: center;
			min-height: 100vh;
			background-color: #f0f0f0;
		}

		canvas {
			border: 1px solid black;
		}
	</style>
</head>

<body>
	<canvas id="mandelbrotCanvas" width="800" height="800"></canvas>

	<script>
		const canvas = document.getElementById('mandelbrotCanvas');
		const ctx = canvas.getContext('2d');

		const width = canvas.width;
		const height = canvas.height;

		// Complex plane boundaries
		let xMin = -2.5;
		let xMax = 1.5;
		let yMin = -2.0;
		let yMax = 2.0;

		const maxIterations = 100;
		const escapeRadiusSquared = 4;

		// Variables to track panning state
		let isPanning = false;
		let startPanX = 0;
		let startPanY = 0;

		function drawMandelbrot() {
			// Quick visual feedback that we are redrawing
			ctx.fillStyle = "#f0f0f0"; // Same as body background
			ctx.fillRect(0, 0, width, height);

			// Use a timeout to allow the browser to render the cleared canvas first
			setTimeout(() => {
				const imageData = ctx.createImageData(width, height);
				const pixels = imageData.data;

				for (let px = 0; px < width; px++) {
					for (let py = 0; py < height; py++) {
						const c_real = xMin + (px / width) * (xMax - xMin);
						const c_imag = yMin + (py / height) * (yMax - yMin);

						let zr = 0.0;
						let zi = 0.0;
						let iterations = 0;

						while (zr * zr + zi * zi < escapeRadiusSquared && iterations < maxIterations) {
							const zr_new = zr * zr - zi * zi + c_real;
							const zi_new = 2 * zr * zi + c_imag;
							zr = zr_new;
							zi = zi_new;
							iterations++;
						}

						const pixelIndex = (py * width + px) * 4;

						if (iterations === maxIterations) {
							pixels[pixelIndex] = 0;
							pixels[pixelIndex + 1] = 0;
							pixels[pixelIndex + 2] = 0;
							pixels[pixelIndex + 3] = 255;
						} else {
							const colorValue = Math.floor((iterations / maxIterations) * 255);
							pixels[pixelIndex] = colorValue;
							pixels[pixelIndex + 1] = colorValue * 2;
							pixels[pixelIndex + 2] = 255 - colorValue;
							pixels[pixelIndex + 3] = 255;
						}
					}
				}
				ctx.putImageData(imageData, 0, 0);
				console.log("Draw complete."); // For feedback
			}, 0);
		}

		// Event listener for when the mouse button is pressed
		canvas.addEventListener('mousedown', (event) => {
			isPanning = true;
			startPanX = event.offsetX;
			startPanY = event.offsetY;
		});

		// Event listener for when the mouse moves
		canvas.addEventListener('mousemove', (event) => {
			if (!isPanning) {
				return;
			}
			// We'll add real-time feedback here in the next step
		});

		// Event listener for when the mouse button is released
		canvas.addEventListener('mouseup', (event) => {
			if (!isPanning) {
				return;
			}
			isPanning = false;

			// NEW: All the panning logic is here!
			const endPanX = event.offsetX;
			const endPanY = event.offsetY;

			const deltaX = endPanX - startPanX;
			const deltaY = endPanY - startPanY;

			// Calculate the range of the complex plane currently visible
			const xRange = xMax - xMin;
			const yRange = yMax - yMin;

			// Calculate the shift in complex plane coordinates
			const dx = (deltaX / width) * xRange;
			const dy = (deltaY / height) * yRange;

			// Update the boundaries. Note we subtract because moving the mouse
			// right (positive deltaX) means we want to see more to the left (decrease xMin).
			xMin -= dx;
			xMax -= dx;
			yMin -= dy;
			yMax -= dy;

			// Redraw the mandelbrot set with the new coordinates
			drawMandelbrot();
		});

		drawMandelbrot();
	</script>
</body>

</html>